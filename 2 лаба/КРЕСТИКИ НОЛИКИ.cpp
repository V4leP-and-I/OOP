#include <iostream>
using namespace std;

class X0
{
private://в private будут записаны массив поля и все методы, вызываемые из метода igra
	char pole[4][4]; //создание массива для поля

	//делаем ход
	void shag(int x, int y, int i)
	{
		if (i % 2) //если iтый номер делится на 2 с остатком, значит ход второго игрока
			pole[x][y] = '0';
		else //инче - ход первого игрока
			pole[x][y] = 'X';
		pokazaty(); //выводим поле на экран
	}

	//вывод поля
	void pokazaty()
	{
		cout << endl << "Поле:" << endl;
		cout << "  " << 1 << " " << 2 << " " << 3 << endl; //выод номеров координат по горизонтали
		for (int i = 1; i < 4; i++) 
		{
			for (int j = 1; j < 4; j++) 
			{
				if (j == 1) // вывод номеров координат по вертикали
					cout << i << ' '; 

				if ((pole[i][j] == 'X') || (pole[i][j] == '0')) //проверка условия, что элемент массива заполнен 'X' или '0', и вывод поля с добавленным символом
					cout << pole[i][j] << ' '; 
				else //иначе в пустых клетках ставим '.'
					cout << '.' << ' ';
			}
			cout << endl;
		}
	}

	//проверка победителя
	int proverka()
	{
		//перебор всевозможных вариантов
		if (((pole[1][1] == 'X') && (pole[1][2] == 'X') && (pole[1][3] == 'X')) || ((pole[1][1] == '0') && (pole[1][2] == '0') && (pole[1][3] == '0')))
		{
			return 0;
		}
		if (((pole[2][1] == 'X') && (pole[2][2] == 'X') && (pole[2][3] == 'X')) || ((pole[2][1] == '0') && (pole[2][2] == '0') && (pole[2][3] == '0')))
		{
			return 0;
		}
		if (((pole[3][1] == 'X') && (pole[3][2] == 'X') && (pole[3][3] == 'X')) || ((pole[3][1] == '0') && (pole[3][2] == '0') && (pole[3][3] == '0')))
		{
			return 0;
		}
		if (((pole[1][1] == 'X') && (pole[2][2] == 'X') && (pole[3][3] == 'X')) || ((pole[3][1] == '0') && (pole[3][2] == '0') && (pole[3][3] == '0')))
		{
			return 0;
		}
		if (((pole[3][1] == 'X') && (pole[2][2] == 'X') && (pole[1][3] == 'X')) || ((pole[3][1] == '0') && (pole[2][2] == '0') && (pole[1][3] == '0')))
		{
			return 0;
		}
		if (((pole[1][1] == 'X') && (pole[2][1] == 'X') && (pole[3][1] == 'X')) || ((pole[1][1] == '0') && (pole[2][1] == '0') && (pole[3][1] == '0')))
		{
			return 0;
		}
		if (((pole[1][2] == 'X') && (pole[2][2] == 'X') && (pole[3][2] == 'X')) || ((pole[1][2] == '0') && (pole[2][2] == '0') && (pole[3][2] == '0')))
		{
			return 0;
		}
		if (((pole[1][3] == 'X') && (pole[2][3] == 'X') && (pole[3][3] == 'X')) || ((pole[1][3] == '0') && (pole[2][3] == '0') && (pole[3][3] == '0')))
		{
			return 0;
		}
		else
			return 1;
	}


public: //чтобы пользователь не мог вызывать другие методы самостоятельно, нарушая ход игры, в public оставим только метод, реализующий механизм игры
	void igra()
	{
		pokazaty(); //вызываем метод, который выводит пустое поле на экран

		for (int i = 0; i < 9; i++) //начинаем цикл шагов
		{
			cout << endl << i%2+1 << " игрок, ведите координаты: ";

			int x, y;
			cin >> x >> y;

			shag(x, y, i); 

			int result = proverka(); //в rezult сохраняем возвращенноё значение метода proverka()

			if (result == 0) //если result 0, выводим на экран победителя и останавливаем цикл
			{
				cout << "Победил " << i % 2 + 1 << " игрок." << endl;
				break;
			}

			if (i == 8) //если было сделано 9 шагов и никто не победил, сообщаем о ничье
			{
				cout << "Победила дружба! :)" << endl;
			}
		}
	}
};

void main()
{
	setlocale(LC_ALL, "rus");

	X0 pt;
	pt.igra();
}